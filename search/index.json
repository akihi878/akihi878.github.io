[{"content":"MSYS2安装git和配置ssh [TOC]\n安装git和配置ssh\n使用 msys2 意味着需要删除 git bash， 原因是 git for windows 是基于 msys2 的， 两者都装容易冲突。 安装 msys2 后可以用包管理工具 pacman 安装 git.\n安装git 建议直接使用msys2提供的git兼容性更好.\n1 pacman -S git 从别的博主的博文学来一个git实用(装Bility)工具onefetch（ https://github.com/o2sh/onefetch ）\n它将直接在终端中展示本地 Git 仓库的项目详情和代码统计等内容。工具完全离线可用（不需要网络连接)\n1 pacman -S mingw-w64-ucrt-x86_64-onefetch 查看git版本\n1 git version 安装成功\n使用ssh配置git仓库链接 SSH安装 win10后面的版本基本上自带了openssh.\n如若没有，可以直接在系统可选功能中找到并下载\n安装即可\n查看SSH位置 可以直接在msys2 中随意挑选一个环境进入（如UCRT64）里使用ssh 这个命令， 如果你用which 查一下，就能发现ssh.exe它的位置是：\n1 2 $ which ssh /c/Windows/System32/OpenSSH/ssh 也就是 C:\\Windows\\System32\\OpenSSH\\ssh.exe\n查阅相关资料发现，若是前面我们通过pacman安装git时会默认安装依赖openssh, 因此，openssh的ssh客户端会有比windows自带的优先级更高.\n此时再查找会发现在usr目录下了，根据Msys官网，这就是usr就是msys的目录，其他环境比如ucrt64可以调用它的。\n1 2 $ which ssh /usr/bin/ssh 打开命令提示符或 Powershell，执行以下命令来检查 OpenSSH 客户端是否已经正确安装：\n1 ssh 查看版本\n1 ssh -V 如果返回的版本号显示SSH已成功安装，则表示一切正常。您现在可以在Windows系统上使用SSH进行远程连接和管理。\n此时ssh已经安装完毕了，可以配置密钥来连接了\n创建 SSH 个人配置文件 主要是需要找到.ssh文件夹，没找到就新建\n查看是否已经有密钥\n输入 ls -al ~/.ssh 以查看是否存在现有的 SSH 密钥，没有自然要新建了。\n有两个主要的SSH配置文件：用户级别的~/.ssh/config和系统级别的/etc/ssh/ssh_config。了解并正确配置这两个文件可以大大提高SSH连接的速度和可靠性。当您安装 SSH 时，您将自动创建一个 ~/.ssh 目录。这直接包含你的公钥、私钥一个known_hosts文件。您的配置也存储在这里。在 Ubuntu 上，默认情况下不会创建 SSH 配置文件。\n~/.ssh和~/.ssh/config 很重要，几乎所有ssh相关的操作都相关。\n用户级别的配置文件：~/.ssh/config 这个文件通常位于用户的主目录下，是专为单个用户优化的SSH配置。你可以在其中为特定的主机或主机组设置连接参数，如端口号、用户名、密码等。\n1 2 3 4 5 6 7 Host 别名 HostName\t主机名 Port 端口 User 用户名 IdentityFile 密钥文件的路径 IdentitiesOnly 只接受SSH key 登录 PreferredAuthentications 强制使用Public Key验证 例如：\n1 2 3 4 Host myserver HostName mydomain.com User username Port 2222 在这个例子中，我们为名为myserver的主机设置了特定的用户名和端口号。当你通过SSH连接到myserver时，它将使用这些特定的参数进行连接。\n在msys中，我找了很久都没有找到这个隐藏文件夹.ssh，就连在用ssh配置github生成密钥的时候，也没有直接建立出.ssh。查了好久，最后自己创建了.ssh文件夹，将密钥文件放进去了。\n然后config也没有，也是自己新建然后查阅后配置了密钥\n最后我是放在了C:\\msys64\\home\\Alvarez\\ssh中的\n​\t如果文件 ~/.ssh/config 不存在，您可以继续创建它。通常，此文件存在于 .ssh“隐藏”目录中，隐藏只是因为大多数操作系统不显示以 . 开头的目录。此外，该目录通常位于一个人的主目录或运行 ssh 的用户的主目录中，因此 ~ 符号表示主目录。\n​\n配置 SSH 秘钥 根据 github 文档，在客户端创建SSH公钥和私钥对，并将私钥添加到客户端的 ssh-agent 中。记得将所给代码改成自己的user地址 将公钥配置在 github 的相应账户中 验证配置连接 测试配置是否成功\n1 ssh -T git@github.com 如果看到如下结果，则证明配置成功，否则需要根据错误消息进行修改。\nHi yourusername! You’ve successfully authenticated, but GitHub does not provide shell access.\n参考 ssh agent详解\n为什么 ssh-agent 需要使用 eval 来运行\n通过 ssh config 配置 Git 多账户 SSH 登录\n附录 参考文献 版权信息 本文原载于[Alvarez\u0026rsquo;s Blog](Alvarez\u0026rsquo;s Blog (akihi878.github.io))，遵循CC BY-NC-SA 4.0协议，复制请保留原文出处。\n","date":"2024-06-16T14:27:12+08:00","permalink":"https://akihi878.github.io/post/msys2%E5%AE%89%E8%A3%85git%E5%B9%B6%E9%85%8D%E7%BD%AEssh/","title":"MSYS2安装git并配置ssh"},{"content":"终端和shell [TOC]\n学习笔记\n参考别人的博客\n为什么我要使用Windows Terminal而不是PowerShell？ 我不需要WSL（Windows Subsystem for Linux）来使用bash，我使用Cygwin。 我能使用带着PowerShell内核的ConEmu吗？还是说我需要使用Windows Terminal？ 终端和shell关系？ 让我们先来澄清几个相关专业术语的概念。\n终端只负责提供一个输出和输入的环境，而shell负责把你的操作或者命令解释成机器码传递给系统内核执行最后再返回结果给终端 然后终端再显示给你看\n一、Linux 介绍 1、什么是 Linux Linux 就是一个操作系统，全称 GNU/Linux，是一种类 Unix 操作系统\n​\tLinux 一开始是没有图形界面的，所有操作都靠命令完成。如 “磁盘操作、文件存取、目录操作、进程管理、文件权限” 等等，可以说 Linux 就是由命令行组成的操作系统。\n​\t大家更熟悉的 Windows 系统，一般用户都是在纯图形化界面下进行操作的，依靠鼠标和键盘操作，上手比较简单。\n​\t现在的 Linux 兼具图形化界面操作和完全的命令行操作，但 命令行操作 仍然是 Linux 的 精髓 所在，命令行下只用键盘就能完成所有操作。\n2、Linux 的两个基本思想 一切皆文件 每个文件都有确定的用途\n二、终端 和 Shell ​ 学习 Linux 一定会经常碰到终端和shell，在 Ubuntu 系统下点击鼠标右键 - “打开终端” 就能打开一个终端窗口，接着我们就能输入命令了。\n进入黑黑的那个框并不是 shell！！！\n终端 和 shell 是两个不同的概念。\n终端是 terminal，而 shell 的意思是 “壳\u0026quot;，这两个怎么看都不会是同一个东西。\n1、什么是终端（Terminal） ​\t终端是与计算机系统相连的一种输入、输出设备，通常离计算机较远 。终端就是人与计算机交互的接口。Unix 和 Linux 把这些人机交互的接口统称为 —— 终端。\n​\t可以简单将终端理解为 “鼠标、键盘、显示器、扬声器、麦克风” 等硬件设备。\n【早期的终端】 早期的终端是一种叫做 电传打字机 - Teletype 的东西。当时还没有个人电脑，普通的计算机都有衣柜那么大，而且很昂贵，人手一台的可能性很低。但是一个用户占有一台计算机未免有点浪费，为了提高计算机的使用效率，Unix 的创始人 Ken Thompson 和 Dennis Ritchie 打算设计一个能够支持多用户进行操作的操作系统（也就是现在的 Unix），实现将一台计算机提供给多位用户进行使用。\n​\t想要实现多用户操作，首先需要给每位用户提供一套基本的输入输出设备来进行操作。但是当时的计算机设备都非常昂贵，每位用户人手一套的话费用也忒高了。所以最后他们找到了更便宜的 电传打字机 来作为替代，也就是下图的 ASR-33 电传打字机。\n可以看出它有键盘和纸带，用户可以通过键盘向计算机输入信息，然后计算机通过在纸带上打印输出结果。这样看来，电传打字机完全可以作为人机交互设备使用。\n​ 于是 Unix 成为了世界上第一个支持多用户的操作系统，而 ASR-33 成为了第一个 Unix 终端\n【现在的终端】 随着计算机快速发展，其硬件设备也越来越便宜且先进。像电传打字机这样的早期终端设备早已退出历史舞台，取而代之的是 键盘、鼠标、显示器 等设备。\n​\t虽然现在电传打字机已经不再适用，但它也是计算机发展的一个重要象征。所以 Teletype 的缩写 TTY 沿用至今，作为各种类型的终端设备的统称。（我们现在看到的 tty 不再单纯指电传打字机，而是指各种各样的终端设备）\n台式机的终端输入设备包括：键盘、鼠标、麦克风；终端输出设备包括：显示器、扬声器\n2、Linux 终端 ​ 为什么 Linux 上的终端和上面说的终端感觉不太一样呢 ？\n​\t实际上，前面我们说的终端指的都是物理的终端设备，而我们在 Linux 上常说的终端其实是 终端模拟器 - Terminal Emulator（一种 模拟终端的程序 ），也称为 —— 虚拟终端 ，但平时一般直接称为终端。可以将 Linux 终端看作一个使用软件来模拟的输入、输出设备，其作用就是提供一个命令的输入、输出环境。Linux 终端是基于物理终端之上的。\n在 Linux 操作系统中，为了让多个用户登录系统进行操作，或打开多个窗口执行多个任务，Linux 设置了多个虚拟终端设备。\n在 Linux 下 Ctrl + Alt + t 即可打开终端（Ctrl + d 关闭终端）\n【终端模拟器出现的原因】 电传打字机时代是没有图形接口的，计算机直接从打字机读取用户的输入，然后自动将计算结果打印到纸带，是非常典型的命令行操作模式。随着计算机发展，出现了各种各样的图形接口，很多操作系统也以图形界面操作为主。大部分的程序都能通过图形接口进行交互，但是仍然存在一些传统的命令行程序还不兼容图形接口，只能通过命令行进行交互。\n​\t但是现在已经没有电传打字机了，这些传统程序不能直接读取用户的键盘输入，也不能将计算结果直接输出到显示器（比如我们现在返回电脑桌面，随便在键盘上输入一些命令，是不会有什么反应的），这种情况下我们要如何运行这些程序呢？—— 【终端模拟器】\n​\t终端模拟器就是一个模拟传统终端设备进行命令行操作的程序。在该程序内输入的命令能够被计算机读取和执行，并将结果输出到显示器。简单来说，终端模拟器就是模拟了一台电传打字机，所以我们一般也直接称之为终端。\n​\t当我们在软件意义上提到终端时，我们指的是 TTY 或 硬件终端 的文字软件版本，也就是负责输入输出命令行的东西。Windows 终端就是其中之一。它非常善于显示文本输出，也可以接受输入并将其传递下去。但是终端并不“聪明”，因为它实际上并不对你的输入做任何处理，也不会看你的文件或进行任何”思考“，它只负责接收输入和显示输出，负责处理你输入信息的另有其人。\n3.CONSOLE（控制台） 在20世纪中期，人们的起居室里会有一种家具，叫做控制台或陈列柜。而在计算机领域，控制台指的是计算机的操控台或者一个内置屏幕和键盘的机柜，但它本质上仍是一个终端（计算机领域）。\n​\t从（计算机）技术上讲，控制台是硬件设备，而终端则是其内部运行的软件程序。\n而在软件世界中提到控制台和终端时，它们实际上是同义词。（例如IDE和编辑器中的内置终端，也叫控制台)\n4.Shell（操作系统外壳，区别于操作系统内核） ​\tShell 指 “提供给使用者使用界面” 的软件，即 Command Interpreter - 命令解析器。Shell 接收用户或者其他应用程序的命令，然后将这些命令转化成内核能够理解的语言并传递给内核，内核执行命令完成后，再将执行结果返回给用户或者应用程序。\n​\tShell 是包裹在操作系统 外层 的一道程序，负责外界与 Linux “内核” 的交互，但它隐藏了操作系统底层的具体细节，就像是 Linux 内核的一个 “外壳”，所以 Shell（壳）的名称也由此而来。\n图形化界面也是一种广义的 Shell，因为图形界面操作的本质也是 —— 将用户的命令传递给内核执行\n​\t之前提到的终端，会接受用户的输入并将其发送给另一个程序，这个应用程序就是Shell。Shell 会接收你通过终端/控制台输入的命令并将其\u0026quot;翻译\u0026quot;成操作系统内核可以理解的语言，然后调用相应的应用程序，最后生成输出并将其传递回终端以显示给用户。这里是一些常见的shell：\nbash, fish, zsh, ksh, sh, tsch PowerShell, cmd, pwsh yori, 4dos, command.com 注意：你对终端的选择不会也不应该影响你对Shell的选择，例如，理论上你可以使用Windows Terminal作为你的终端，并使用zsh作为你的Shell（这实际上不太可行，因为zsh不能很好地运行在Windows操作系统上，除非你使用WSL）\n冷知识: WSL 和 WSL2(the Windows Subsystem for Linux)是一个或多个完整的，运行在Windows 10上的本地 Linux。这些Linux系统是完整且真实的。WSL2通过虚拟技术，提供了一个真正的 Linux 内核，并在 Windows 上运行。而Cygwin不是真正的 Linux。Cygwin 是 GNU 和开源工具的一个大集合，它们提供了类似于 Windows 上的 Linux 的功能——但它不是 Linux。这是一个幻影。它是针对 Win32 编译的 GNU utils。这很不错，但重要的是你要知道它们之间的区别。Cygwin 可以让您运行 bash shell 脚本，但它不会运行 Apache、 Docker 或其他真正的 ELF-binaries 和 Linux 应用程序。\nWindows操作系统带有许多Shell 比如PowerShell, cmd 或者自己MSYS2安装的zsh bash\n5、终端 和 Shell 的区别和关联 终端接收命令输入，Shell 翻译并传递命令，内核执行命令。\n终端 只是人机交互的一个接口，提供输入输出命令的交互界面。终端的主要任务是接收用户输入的命令，并提交给 Shell。\nShell 是命令解析器，主要任务是翻译命令。Shell 将终端输入的命令转化成内核能够理解的语言并传递给内核，由内核执行命令，并将执行结果返回给终端。当我们打开终端时，Shell 也会自动启动，操作系统会将终端和 Shell 关联起来。接着我们在终端输入命令，Shell 就负责解释命令。\nsome question 问：萌新请教一下:控制台或者说终端本身也是一种文件吗？也就是说类似常见的磁盘文件也有自己的编码是吗？ 举个例子，如果我要在idea里编程读取一个文本文件的内容输出到控制台，首先我确定我的待读取文件的编码是gbk的，然后我在idea的编程界面（右下角）把编码也改成gbk，然后我运行程序，发现显示在控制台的内容仍然是乱码的。其原因是否是idea的控制台采用的是utf-8？要想完成我上面的要求，是否必须保证磁盘源文件编码，代码文件编码，控制台文件编码都一致才行呢？\n答：终端是一个程序，是一个可执行文件。\n关于输出乱码，如果我没理解错，终端输出文本的编码取决于终端调用的shell，而非终端程序本身。\n换句话说，idea的内置终端会调用你操作系统的shell，比如Windows下可能是cmd或powershell，你应该让操作系统shell和待读取文件的编码方式一致（比如都是gbk）。\n至于idea右下角的编码方式，是针对你写的源代码文件，不管源文件用什么编码，编译后都是可执行文件。而你要输出的是另一个文本文件的内容，所以和源文件编码应该没关系。\nreference Linux 学习笔记（一）：终端 和 Shell 的区别和联系_shell终端-CSDN博客\n[翻译] 控制台（Console），终端（Terminal）和Shell之间的区别究竟是什么？ - 知乎 (zhihu.com)\n附录 参考文献 版权信息 本文原载于[Alvarez\u0026rsquo;s Blog](Alvarez\u0026rsquo;s Blog (akihi878.github.io))，遵循CC BY-NC-SA 4.0协议，复制请保留原文出处。\n","date":"2024-06-16T14:23:15+08:00","permalink":"https://akihi878.github.io/post/%E7%BB%88%E7%AB%AF/","title":"终端"},{"content":"两数之和\u0026amp;三数之和 167.两数之和 II - 输入有序数组:fire: 1 2 3 4 5 6 7 8 9 10 11 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt; \u0026amp;numbers, int target) { int left = 0, right = numbers.size() - 1; for (;;) { // left \u0026lt; right int s = numbers[left] + numbers[right]; if (s == target) return {left + 1, right + 1}; s \u0026gt; target ? --right : ++left; } } }; 总结 若是暴力做法，直接是n方的复杂度，但是需要用上有序列表的条件；\n例如 2 3 4 8 9 一开始选择2 9 若是得到6，那么11大于6，9已经是最大的了，若还是2右移为3，那么更加大了，只有9左移；同理，若是比target小的时候，左边的数小，右移动；\n这是关键思想，之后三数之和也是这个思路；\n灵神的题解更简洁，其中这道题保证唯一有解，所以一开始进入一个无限循环；\n用三目运算更方便；\n错解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; numbers, int target) { int n=numbers.size(); int left=0,right=n-1; vector\u0026lt;int\u0026gt; res; while(left\u0026lt;right){ if(numbers[left]+numbers[right]\u0026gt;target) right--; else if(numbers[left]+numbers[right]\u0026lt;target) left++; else{ res.emplace_back(left+1); res.emplace_back(right+1); // break; return res; } } // return res; // return {left + 1, right + 1}; } }; 错因在于对于循环控制条件没有写好，编译器认为你没有考虑完所有情况；这时要么别用这种if elseif结构；要么对其中进行break，可以解决报错；\n修改后\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; numbers, int target) { int n=numbers.size(); int left=0,right=n-1; while(left\u0026lt;right){ if(numbers[left]+numbers[right]\u0026gt;target) right--; else if(numbers[left]+numbers[right]\u0026lt;target) left++; else break; } return {left + 1, right + 1}; } }; 其中vector可以写成这样也需要注意；\n15.三数之和:fire::fire: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt; \u0026amp;nums) { sort(nums.begin(), nums.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; int n = nums.size(); for (int i = 0; i \u0026lt; n - 2; ++i) { int x = nums[i]; if (i \u0026amp;\u0026amp; x == nums[i - 1]) continue; // 跳过重复数字 if (x + nums[i + 1] + nums[i + 2] \u0026gt; 0) break; // 优化一 if (x + nums[n - 2] + nums[n - 1] \u0026lt; 0) continue; // 优化二 int j = i + 1, k = n - 1; while (j \u0026lt; k) { int s = x + nums[j] + nums[k]; if (s \u0026gt; 0) --k; else if (s \u0026lt; 0) ++j; else { ans.push_back({x, nums[j], nums[k]}); j++;//形如 2 3 4 5 已经有了2 5 再找 3 4 while(j\u0026lt;k\u0026amp;\u0026amp;nums[j] == nums[j - 1]) ++j; k--; while(j\u0026lt;k\u0026amp;\u0026amp;nums[k] == nums[k + 1]) --k; } } } return ans; } }; 总结 其实就是先定下来i，然后在i的基础上做j与k的两数之和；\n最后要考虑清晰关于重复数字的情况，一步步来考虑，别一开始就考虑重复数字的情形；\n此处好几个难点\nif (x + nums[i + 1] + nums[i + 2] \u0026gt; 0) break; // 优化一 if (x + nums[n - 2] + nums[n - 1] \u0026lt; 0) continue; // 优化二 优化2处不可以用break，因为优化1处，当前i 与它之后的两个必定是此时所有数最小的了，之后没有比他更小的了，break；\n但是当前i加上数组末尾的两个数确实不是当前最大的，因为i不一定是倒数第三；这个前往小心\n附录 参考文献 版权信息 本文原载于[Alvarez\u0026rsquo;s Blog](Alvarez\u0026rsquo;s Blog (akihi878.github.io))，遵循CC BY-NC-SA 4.0协议，复制请保留原文出处。\n","date":"2024-06-08T15:09:17+08:00","image":"https://akihi878.github.io/post/leetcode12/cover_hu603933a3dabc322a2c5576b84b22d8d1_289816_120x120_fill_box_smart1_3.png","permalink":"https://akihi878.github.io/post/leetcode12/","title":"Leetcode12"},{"content":"诗词歌赋 《清平乐·留人不住》 朝代：宋代作者：晏几道\n留人不住，醉解兰舟去。一棹碧涛春水路，过尽晓莺啼处。\n渡头杨柳青青，枝枝叶叶离情。此后锦书休寄，画楼云雨无凭。\n附录 参考文献 版权信息 本文原载于[Alvarez\u0026rsquo;s Blog](Alvarez\u0026rsquo;s Blog (akihi878.github.io))，遵循CC BY-NC-SA 4.0协议，复制请保留原文出处。\n","date":"2024-06-08T12:41:33+08:00","image":"https://akihi878.github.io/post/first/cover_hu5ec19d1304840846577ba95f8e511366_267704_120x120_fill_box_smart1_3.png","permalink":"https://akihi878.github.io/post/first/","title":"First"}]