[{"content":"两数之和\u0026amp;三数之和 167.两数之和 II - 输入有序数组:fire: 1 2 3 4 5 6 7 8 9 10 11 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt; \u0026amp;numbers, int target) { int left = 0, right = numbers.size() - 1; for (;;) { // left \u0026lt; right int s = numbers[left] + numbers[right]; if (s == target) return {left + 1, right + 1}; s \u0026gt; target ? --right : ++left; } } }; 总结 若是暴力做法，直接是n方的复杂度，但是需要用上有序列表的条件；\n例如 2 3 4 8 9 一开始选择2 9 若是得到6，那么11大于6，9已经是最大的了，若还是2右移为3，那么更加大了，只有9左移；同理，若是比target小的时候，左边的数小，右移动；\n这是关键思想，之后三数之和也是这个思路；\n灵神的题解更简洁，其中这道题保证唯一有解，所以一开始进入一个无限循环；\n用三目运算更方便；\n错解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; numbers, int target) { int n=numbers.size(); int left=0,right=n-1; vector\u0026lt;int\u0026gt; res; while(left\u0026lt;right){ if(numbers[left]+numbers[right]\u0026gt;target) right--; else if(numbers[left]+numbers[right]\u0026lt;target) left++; else{ res.emplace_back(left+1); res.emplace_back(right+1); // break; return res; } } // return res; // return {left + 1, right + 1}; } }; 错因在于对于循环控制条件没有写好，编译器认为你没有考虑完所有情况；这时要么别用这种if elseif结构；要么对其中进行break，可以解决报错；\n修改后\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; numbers, int target) { int n=numbers.size(); int left=0,right=n-1; while(left\u0026lt;right){ if(numbers[left]+numbers[right]\u0026gt;target) right--; else if(numbers[left]+numbers[right]\u0026lt;target) left++; else break; } return {left + 1, right + 1}; } }; 其中vector可以写成这样也需要注意；\n15.三数之和:fire::fire: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt; \u0026amp;nums) { sort(nums.begin(), nums.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; int n = nums.size(); for (int i = 0; i \u0026lt; n - 2; ++i) { int x = nums[i]; if (i \u0026amp;\u0026amp; x == nums[i - 1]) continue; // 跳过重复数字 if (x + nums[i + 1] + nums[i + 2] \u0026gt; 0) break; // 优化一 if (x + nums[n - 2] + nums[n - 1] \u0026lt; 0) continue; // 优化二 int j = i + 1, k = n - 1; while (j \u0026lt; k) { int s = x + nums[j] + nums[k]; if (s \u0026gt; 0) --k; else if (s \u0026lt; 0) ++j; else { ans.push_back({x, nums[j], nums[k]}); j++;//形如 2 3 4 5 已经有了2 5 再找 3 4 while(j\u0026lt;k\u0026amp;\u0026amp;nums[j] == nums[j - 1]) ++j; k--; while(j\u0026lt;k\u0026amp;\u0026amp;nums[k] == nums[k + 1]) --k; } } } return ans; } }; 总结 其实就是先定下来i，然后在i的基础上做j与k的两数之和；\n最后要考虑清晰关于重复数字的情况，一步步来考虑，别一开始就考虑重复数字的情形；\n此处好几个难点\nif (x + nums[i + 1] + nums[i + 2] \u0026gt; 0) break; // 优化一 if (x + nums[n - 2] + nums[n - 1] \u0026lt; 0) continue; // 优化二 优化2处不可以用break，因为优化1处，当前i 与它之后的两个必定是此时所有数最小的了，之后没有比他更小的了，break；\n但是当前i加上数组末尾的两个数确实不是当前最大的，因为i不一定是倒数第三；这个前往小心\n附录 参考文献 版权信息 本文原载于reincarnatey.net，遵循CC BY-NC-SA 4.0协议，复制请保留原文出处。\n","date":"2024-06-08T15:09:17+08:00","image":"https://akihi878.github.io/post/leetcode12/cover_hu603933a3dabc322a2c5576b84b22d8d1_289816_120x120_fill_box_smart1_3.png","permalink":"https://akihi878.github.io/post/leetcode12/","title":"Leetcode12"},{"content":"Hugo 似乎直接克隆也不太好 关联主题仓库 我们可以将主题仓库直接 git clone 下来进行使用，例如在根目录robin-site下运行以下代码，即可下载pure主题.\n1 git clone https://github.com/xiaoheiAh/hugo-theme-pure themes/pure 这种方式有一些弊端，当之后自己对主题进行修改后，可能会与原主题产生一些冲突，不方便版本管理与后续更新。官方更推荐使用的是将原主题仓库 fork 到自己的账户，并使用 git submodule 方式进行仓库链接，这样后续可以对主题的修改进行单独维护。\n1 2 3 cd robin-site/ git init git submodule add https://github.com/pseudoyu/pure themes/pure https://jianzhnie.github.io/post/hugo_site/\ngit clone的关键字\ngit clone \u0026ndash;depth 1 \u0026ndash;recursive\n不同的用法\ngo 使用sssh关连 git remote add origin git@github.com:akihi878/akihi878.github.io.git https://docs.github.com/zh/pages/quickstart快速建立给gitpage\ngit\nhttps://cloud.tencent.com/developer/article/2136829\nhttps://pengfeixc.com/blogs/developer-handbook/git-submodules\n子模块\n选择主题\n直接GitHub搜索hugo-theme\n使用了\n、\n不要选tich content\n先链接仓库 再 add 再commit 再push\n1 2 3 4 5 6 7 cd public git init git remote add origin 你的仓库地址.git git add -A git commit -m \u0026#34;create\u0026#34; git branch -M main git push -u origin main 妈的 edge 查看不了 icon 1 git remote add origin git@github.com:akihi878/akihi878.github.io.git 1 git remote add origin https://github.com/akihi878/akihi878.github.io # 将本地目录链接到远程服务器的代码仓库 https://github.com/akihi878/akihi878.github.io\nHugo插件-Waline (cloudorz.com)\n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\n深入对比TOML，JSON和YAML - sunsky303 - 博客园 (cnblogs.com)\n1 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 附录 参考文献 版权信息 本文原载于reincarnatey.net，遵循CC BY-NC-SA 4.0协议，复制请保留原文出处。\n","date":"2024-06-08T15:08:41+08:00","image":"https://akihi878.github.io/post/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/cover_hu603933a3dabc322a2c5576b84b22d8d1_289816_120x120_fill_box_smart1_3.png","permalink":"https://akihi878.github.io/post/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","title":"Hugo搭建博客"},{"content":"诗词歌赋 《清平乐·留人不住》 朝代：宋代作者：晏几道\n留人不住，醉解兰舟去。一棹碧涛春水路，过尽晓莺啼处。\n渡头杨柳青青，枝枝叶叶离情。此后锦书休寄，画楼云雨无凭。\n附录 参考文献 xxxx\n版权信息 ","date":"2024-06-08T12:41:33+08:00","image":"https://akihi878.github.io/post/first/cover_hu5ec19d1304840846577ba95f8e511366_267704_120x120_fill_box_smart1_3.png","permalink":"https://akihi878.github.io/post/first/","title":"First"}]