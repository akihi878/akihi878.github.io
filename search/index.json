[{"content":"附录 参考文献 版权信息 本文原载于reincarnatey.net，遵循CC BY-NC-SA 4.0协议，复制请保留原文出处。\n调整pad\n","date":"2024-06-11T12:28:20+08:00","permalink":"https://akihi878.github.io/post/second/","title":"Second"},{"content":"附录 参考文献 版权信息 本文原载于reincarnatey.net，遵循CC BY-NC-SA 4.0协议，复制请保留原文出处。\n调整pad\n","date":"2024-06-10T23:25:11+08:00","permalink":"https://akihi878.github.io/post/firstsss/","title":"Firstsss"},{"content":"两数之和\u0026amp;三数之和 167.两数之和 II - 输入有序数组:fire: 1 2 3 4 5 6 7 8 9 10 11 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt; \u0026amp;numbers, int target) { int left = 0, right = numbers.size() - 1; for (;;) { // left \u0026lt; right int s = numbers[left] + numbers[right]; if (s == target) return {left + 1, right + 1}; s \u0026gt; target ? --right : ++left; } } }; 总结 若是暴力做法，直接是n方的复杂度，但是需要用上有序列表的条件；\n例如 2 3 4 8 9 一开始选择2 9 若是得到6，那么11大于6，9已经是最大的了，若还是2右移为3，那么更加大了，只有9左移；同理，若是比target小的时候，左边的数小，右移动；\n这是关键思想，之后三数之和也是这个思路；\n灵神的题解更简洁，其中这道题保证唯一有解，所以一开始进入一个无限循环；\n用三目运算更方便；\n错解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; numbers, int target) { int n=numbers.size(); int left=0,right=n-1; vector\u0026lt;int\u0026gt; res; while(left\u0026lt;right){ if(numbers[left]+numbers[right]\u0026gt;target) right--; else if(numbers[left]+numbers[right]\u0026lt;target) left++; else{ res.emplace_back(left+1); res.emplace_back(right+1); // break; return res; } } // return res; // return {left + 1, right + 1}; } }; 错因在于对于循环控制条件没有写好，编译器认为你没有考虑完所有情况；这时要么别用这种if elseif结构；要么对其中进行break，可以解决报错；\n修改后\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; numbers, int target) { int n=numbers.size(); int left=0,right=n-1; while(left\u0026lt;right){ if(numbers[left]+numbers[right]\u0026gt;target) right--; else if(numbers[left]+numbers[right]\u0026lt;target) left++; else break; } return {left + 1, right + 1}; } }; 其中vector可以写成这样也需要注意；\n15.三数之和:fire::fire: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt; \u0026amp;nums) { sort(nums.begin(), nums.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; int n = nums.size(); for (int i = 0; i \u0026lt; n - 2; ++i) { int x = nums[i]; if (i \u0026amp;\u0026amp; x == nums[i - 1]) continue; // 跳过重复数字 if (x + nums[i + 1] + nums[i + 2] \u0026gt; 0) break; // 优化一 if (x + nums[n - 2] + nums[n - 1] \u0026lt; 0) continue; // 优化二 int j = i + 1, k = n - 1; while (j \u0026lt; k) { int s = x + nums[j] + nums[k]; if (s \u0026gt; 0) --k; else if (s \u0026lt; 0) ++j; else { ans.push_back({x, nums[j], nums[k]}); j++;//形如 2 3 4 5 已经有了2 5 再找 3 4 while(j\u0026lt;k\u0026amp;\u0026amp;nums[j] == nums[j - 1]) ++j; k--; while(j\u0026lt;k\u0026amp;\u0026amp;nums[k] == nums[k + 1]) --k; } } } return ans; } }; 总结 其实就是先定下来i，然后在i的基础上做j与k的两数之和；\n最后要考虑清晰关于重复数字的情况，一步步来考虑，别一开始就考虑重复数字的情形；\n此处好几个难点\nif (x + nums[i + 1] + nums[i + 2] \u0026gt; 0) break; // 优化一 if (x + nums[n - 2] + nums[n - 1] \u0026lt; 0) continue; // 优化二 优化2处不可以用break，因为优化1处，当前i 与它之后的两个必定是此时所有数最小的了，之后没有比他更小的了，break；\n但是当前i加上数组末尾的两个数确实不是当前最大的，因为i不一定是倒数第三；这个前往小心\n附录 参考文献 版权信息 本文原载于reincarnatey.net，遵循CC BY-NC-SA 4.0协议，复制请保留原文出处。\n","date":"2024-06-08T15:09:17+08:00","image":"https://akihi878.github.io/post/leetcode12/cover_hu603933a3dabc322a2c5576b84b22d8d1_289816_120x120_fill_box_smart1_3.png","permalink":"https://akihi878.github.io/post/leetcode12/","title":"Leetcode12"},{"content":"诗词歌赋 《清平乐·留人不住》 朝代：宋代作者：晏几道\n留人不住，醉解兰舟去。一棹碧涛春水路，过尽晓莺啼处。\n渡头杨柳青青，枝枝叶叶离情。此后锦书休寄，画楼云雨无凭。\n附录 参考文献 xxxx\n版权信息 ","date":"2024-06-08T12:41:33+08:00","image":"https://akihi878.github.io/post/first/cover_hu5ec19d1304840846577ba95f8e511366_267704_120x120_fill_box_smart1_3.png","permalink":"https://akihi878.github.io/post/first/","title":"First"},{"content":"诗词歌赋s1 《清平乐·留人不住》 朝代：宋代作者：晏几道\n留人不住，醉解兰舟去。一棹碧涛春水路，过尽晓莺啼处。\n渡头杨柳青青，枝枝叶叶离情。此后锦书休寄，画楼云雨无凭。\n附录 参考文献 xxxx\n版权信息 ","date":"2024-06-08T12:41:33+08:00","image":"https://akihi878.github.io/post/s1/cover_hu5ec19d1304840846577ba95f8e511366_267704_120x120_fill_box_smart1_3.png","permalink":"https://akihi878.github.io/post/s1/","title":"s1"}]